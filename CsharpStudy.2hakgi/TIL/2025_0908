2025_0917

실행할수 있는 최소단위 Thread 
시간을 다 나눠서 쓸수 있게 OS가 한다. 
느린애가 있으면 길하나를 터서 가는것 
그래서 비동기를 하는것 

동시성 
CPU에 코어가 있으면 일할수 있는 애들이 여러개 있는것 
동시에 되는것처럼 보이지만 하나  시간을 쪼개서 하는것? 논리적 한명이 동시에 하는것 처럼

병렬성 (동시성과 구분해서 확인할것)
멀티코어 여러 Thread가 일을 한다. 
여러코어가 여러개들을 일을 나눠서 한다.  물리적 실제 동시


동기 - 순서대로 실행 (1차선)

비동기 - 동시에 실행(4차선)

콜백 은 델리게이트나 이벤트에 많이 사용하고,
작업완료후 콜백 호출 하지만 디버깅도 어렵다 .
코루틴은 콜백방식인 옛날방식이다. 
일반 task는 불편해서 코루틴은 옛날방식이고
유닛테스트는 유니티에 최적하된 테스크를 많이 쓴다. 

thread가 3개라면 분배는 OS가 결정하기떄문에 예측이 어렵다.

결국 콜백은 선호하지 않는다.
 에어추적, 가독성 유지보수 저하, 디버깅어렵

Task를 리턴하면 무조건 비동기함수다.

에이씽크 어웨이트 :
예측가능하다. 읽기가 좋고 순차적코드처럼 비동기를
Tty-cath가능해서 에러처리가능


Task.WhenAll()
병령처리 모든작업이 끝나야지만 다음화면으로 넘어가는것을 구현 

동기코드는 오래거리는애가 점유하기떄문에 멈추게 할수 있다.

다시 
Task는 비동기 함수인데 
async 와 await는 비동기 함수를 동기화방식으로 사용하는 함수  
