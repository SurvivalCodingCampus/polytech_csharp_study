## 문자열 

### ✅ 문자열 처리 함수

| 분류 | 함수/속성 | 설명 | 예시 |
| --- | --- | --- | --- |
| 길이/부분 문자열 | `Length` | 문자열 길이를 반환 | `s1.Length` → `5` |
|  | `Substring(int start, int length)` | 특정 위치에서 부분 문자열 추출 | `s1.Substring(1, 3)` → `"ell"` |
| 검색 | `IndexOf(string)` | 특정 문자열이 처음 등장하는 인덱스 반환 | `s1.IndexOf("l")` → `2` |
|  | `LastIndexOf(string)` | 특정 문자열이 마지막으로 등장하는 인덱스 반환 | `s1.LastIndexOf("l")` → `3` |
|  | `Contains(string)` | 특정 문자열 포함 여부 | `s1.Contains("He")` → `true` |
|  | `StartsWith(string)` | 특정 문자열로 시작하는지 여부 | `s1.StartsWith("He")` → `true` |
|  | `EndsWith(string)` | 특정 문자열로 끝나는지 여부 | `s1.EndsWith("lo")` → `true` |
| 수정/가공 | `Replace(string, string)` | 문자열 치환 | `s1.Replace("l", "x")` → `"Hexxo"` |
|  | `ToUpper()` | 대문자로 변환 | `s1.ToUpper()` → `"HELLO"` |
|  | `ToLower()` | 소문자로 변환 | `s1.ToLower()` → `"hello"` |
|  | `Trim()` | 앞뒤 공백 제거 | `"  Hi  ".Trim()` → `"Hi"` |
|  | `TrimStart()`, `TrimEnd()` | 앞/뒤 공백만 제거 | `"  Hi".TrimStart()` → `"Hi"` |
| 분리/결합 | `Split(char[])` | 구분자로 문자열 분리 → 배열 반환 | `"a,b,c".Split(',')` → `["a","b","c"]` |
|  | `Join(separator, array)` | 배열/컬렉션을 구분자로 결합 | `string.Join("-", new[]{"a","b"})` → `"a-b"` |
| 형식/변환 | `Format()` | 서식 문자열을 지정해 값 삽입 | `string.Format("Hi {0}", s1)` → `"Hi Hello"` |
|  | `$"" (interpolation)` | 문자열 보간법 (C#6+) | `$"Hi {s1}"` → `"Hi Hello"` |
| 기타 | `IsNullOrEmpty(str)` | null 또는 빈 문자열인지 확인 | `string.IsNullOrEmpty(s1)` → `false` |
|  | `IsNullOrWhiteSpace(str)` | null, 빈 문자열, 공백만 있는지 확인 | `string.IsNullOrWhiteSpace(s1)` → `false` |

---

### ✅ string은 불변(Immutable) 객체

```csharp
string s1 = "Hello";
// 힙에 "Hello" 인스턴스 생성(예: 주소 100)
// 스택의 s1은 이 주소(100)를 가리킨다.

s1 += "World";
// "Hello" 뒤에 붙는 것이 아니라 "HelloWorld"라는 새 인스턴스가 힙에 생성됨(예: 주소 200)
// 스택의 s1은 이제 새 인스턴스(200)를 가리킨다.
```

- 따라서 `"Hello"`의 해시코드와 `"HelloWorld"`의 해시코드는 서로 다르다.
- 기존 `"Hello"` 인스턴스는 더 이상 참조되지 않으니 **가비지 컬렉션(GC)**에 의해 정리된다.

```csharp
string s1 = "hello";
string s2 = "hello";
```

- C#에서 문자열은 **불변(Immutable) 객체**.
- 동일한 문자열 리터럴 `"hello"`는 **intern pool**에 저장되므로, `s1`과 `s2`는 사실상 같은 객체를 참조한다.
    - **Intern Pool = 동일한 문자열을 한 번만 저장하고 재사용하는 C# 내부 메모리 공간**
        - 문자열 상수 풀(String Intern Pool) 이라고도 부른다 = 컴파일 타임에 생성된다
        - `new` 를 사용해서 런타임 중에 생성된 문자열은 문자열 상수 풀에 들어가지 않는다
        - C#은 **"hello"라는 문자열이 이미 존재하면 새로 만들지 않고 기존 객체를 재사용한다.**
        - 덕분에 문자열 비교와 해시 계산이 효율적이고, 메모리 낭비도 줄일 수 있음.
    - **`new`나 런타임 연산으로 만든 문자열은 자동으로 pool에 들어가지 않는다**
    - 만약 필요하면 `string.Intern()`으로 명시적으로 넣을 수 있다
- `GetHashCode()`는 문자열의 **내용**기반으로 계산되므로 `s1`과 `s2`의 해시코드는 **항상 동일하다.**

```csharp
using System;

public class StringComparison
{
    public static void Main()
    {
        string str1 = "hello";
        string str2 = "hello";
        Console.WriteLine(object.ReferenceEquals(str1, str2)); // true

        string str3 = new string(new char[] { 'h', 'e', 'l', 'l', 'o' });
        Console.WriteLine(object.ReferenceEquals(str1, str3)); // false
        // new를 통해 인스턴스를 새로 생성하니까 = 런타임에 생성되는 문자열이므로

        string str4 = "hel" + "lo";
        Console.WriteLine(object.ReferenceEquals(str1, str4)); // true
        // 컴파일 타임에 생성된 string이므로 문자열 상수 풀에 포함된다
        
        string str5 = "hel" + GetLo();
        Console.WriteLine(object.ReferenceEquals(str1, str5)); // false
        // 런타임에 호출된 함수로 인해 생성된 문자열 리터럴을 반환하므로, false 
    }

    public static string GetLo()
    {
        return "lo";
    }
}
// 모든 클래스는 object를 상속받으므로, 생략이 가능하다
```

- 컴파일 타임에 생성된건 문자열 상수 풀에 들어간다
- 런타임에 생성된건 문자열 상수 풀과 무관한다
- `const` 가 붙은 경우는 컴파일 타임, `static` 이 붙은 경우는 런타임에 해당한다

---

### ✅ StringBuilder 사용 시

```csharp
var sb = new StringBuilder("Hello");
sb.Append("World");
```

- `StringBuilder`는 **가변(Mutable)** 객체다.
- 문자열을 결합할 때, **새로운 인스턴스를 생성하지 않고** 내부 버퍼에 바로 덧붙인다.
- 따라서 `Append`를 여러 번 호출해도 불필요한 인스턴스 생성과 GC 부담이 줄어든다.
- 대량의 문자열 결합/수정 작업에서는 `string`보다 `StringBuilder`가 훨씬 효율적이다.

---

### ✅ string, StringBuilder **정리 `면접 예상 문제`**

- `string` : 불변 객체 → 결합 시마다 새로운 인스턴스 생성, 해시코드도 매번 달라짐.
- `StringBuilder` : 가변 객체 → 내부 버퍼에 수정, 해시코드 개념은 `ToString()` 호출 시점 문자열 기준.
- [참고] https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/strings/

---

### ✅ **Accessor, Mutator**

- Accessor (접근자)
    - **목적:** 클래스의 **필드 값을 읽기만** 할 때 사용 `getter` → return(O)
    - **특징:** 필드 값을 반환하지만, 값을 변경하지 않음
    - 예: `ToUpper()` `Replace()` …
- Mutator (변경자)
    - **목적:** 클래스의 **필드 값을 변경**할 때 사용 `setter` → return(X)
    - **특징:** 내부 데이터 유효성 검사 가능
    - 예: `SetName(string)`, `Append(string)`, `Remove(int, int)` …
