### 서버와 클라이언트

- **서버(Server)**: 요청을 받아 처리하고, 그 결과를 클라이언트에 제공하는 중앙 역할의 컴퓨터/프로그램
- **클라이언트(Client)**: 서버에 요청을 보내고, 그 결과(서비스·데이터)를 사용하는 사용자 측 컴퓨터/프로그램

### 스레드(Thread)

- 프로그램을 실행하는 최소 단위로 프로그램이 실행되면 하나의 메인 스레드가 활성화된다
- 비동기 흐름이 생기면, 다른 스레드가 생성된다

### 동시성(Concurrency)과 병렬성(Parallelism)

1. 동시성(Concurrency)
    - 여러 작업이 논리적으로 동시에 실행되는 것처럼 보이는 개념(싱글 코어)
    - 시분할 방식으로 여러 스레드를 활용해 동시성을 구현할 수 있다
        - (예) 한 명의 선생님이 질문도 받고 숙제도 확인하고 수업 준비도 하는 것과 같다
2. 병렬성(Parallelism)
    - 여러 작업이 물리적으로 동시에 실행되는 개념(멀티 코어)
    - 멀티코어 환경에서 실제로 여러 스레드가 병렬로 실행될 수 있음
        - (예) 선생님과 조교가 함께 일 하는 것과 같다
3. 정리
    - 여러 작업을 처리하는 방식에 대한 차이
    - 동시성: 여러 작업을 번갈아 가며 처리하는 것(논리적)
    - 병렬성: 여러 작업을 실제로 동시에 처리하는 것(물리적)
        - OS에서 처리하는 것이므로, 프로그래머가 강제로 조작할 수 없다

### 동기(sync), 비동기(Async) 예제

```csharp
string jsonString = JsonConvert.SerializeObject(department);

// 동기 방식 → 파일 저장이 끝나야 다음 코드 실행
File.WriteAllText("departement.json", jsonString);

// 비동기 방식 → 저장이 끝나길 기다리지 않고 바로 다음 코드 실행
File.WriteAllTextAsync("departement.json", jsonString)
    .ContinueWith(task => Console.WriteLine("저장 완료: 2")); // 완료 후 실행

Console.WriteLine("저장 완료: 1");

/*
저장 완료: 1
저장 완료: 2
*/

// task.Delay(1000)
```

- `Async` 메서드 = **비동기 함수**
- `ContinueWith()` = **비동기 작업 완료 후 후속 작업 등록** → 비동기가 끝나는 시점을 확인할 수 있다 ****

### 동기(sync) 프로그래밍

- 코드가 순서대로 진행
- 작업이 완료될 때까지 프로그램이 중단될 수 없다
- 모든 작업의 실행이 완료될 때 까지 기다려야 한다

### 비동기(Async) 프로그래밍

- 작업 완료를 기다리지 않고 다른 작업을 시작할 수 있게 허용하는 방식
- **핵심 : 메인 스레드를 절대 막지 않는다**
    - 엄청 큰 다운로드 중에 사용자는 버튼을 누르거나 스크롤을 조작할 수 있음
    - 앱이 버벅거리지 않고 즉각적으로 반응할 수 있도록 할 수 있다
- **비동기 프로그래밍은 동시성, 병렬성 개념을 아주 영리하게 사용해서 성능을 최대한 끌어내는 기술**

### 콜백(CallBack)

- **콜백(Callback)**: 특정 동작이 끝난 뒤 실행되도록 미리 등록해둔 함수
    - (예) `ContinueWith()`
- **콜백 기준의 동기화 방식의 문제점**
    - 코드의 깊이가 깊어지고 관리하기 어려워짐 → 콜백 지옥
        - 디버깅과 병렬처리가 어려움
- **유니티에서 제공하는 코루틴도 콜백 지옥을 벗어날 수 없다 → UniTask를 사용하자**
- 콜백 방식은 `try-catch` 사용을 할 수 없다
- 콜백의 문제점
    - 코드가 깊어져 관리가 어려워져서 디버깅 및 에러 추척이 어렵다
    - 가독성과 유지보수성 급격히 저하

### async, await

- async - await 는 비동기 코드를 작성할 때 더 깔끔한 코드를 제공한다
    - 비동기 코드를 1차선 도로처럼 만들어준다 → 비동기 코드를 예측 가능하게 만들어준다
- await 키워드는 해당 Task 가 끝날 때까지 함수 실행을 기다린다
- `try-catch` 사용 가능하다

### 병렬(Parallelism) 처리

- 병렬 처리는 동시에 여러가지 일을 진행하는 것 ↔ 동시성은 동시에 실행되는 것 같아 보이는 처리
- Task.WhenAll() 는 모든 작업을 **동시에 시작**하여 성능을 극한으로 올리고 모두 끝날 때 까지 기다린다

### 정리

- 동기 코드는 앱을 멈추게 할 수 있다 → 시간이 오래 걸리는 코드가 메인쓰레드가 점유하는 경우도 있으므로
- 콜백은 ‘콜백 지옥'을 만들 수 있다
- `async` `await` 는 깔끔하고 읽기 쉬운 코드를 제공한다
- `Task.WhenAll` 은 진정한 병렬성을 구현한다
- Unity에서는 유니티에 특화된 UniTask 를 주로 사용하여 코루틴을 완벽히 대체한다
- [참고] https://learn.microsoft.com/ko-kr/dotnet/csharp/asynchronous-programming/