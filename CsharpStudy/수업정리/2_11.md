# DTO / Mapper 한 페이지 요약 — Pokemon 예시 (C#/.NET)

> TL;DR
>
>
> DTO는 외부(JSON) 데이터를 **안전하게 수용**하는 중간 그릇, Mapper는 DTO를 **우리 도메인 모델**로 깔끔히 **변환/평탄화**하는 단계.
>

---

## 왜 DTO가 필요한가

- **계층 분리**: 외부 API 스키마 ↔ 내부 도메인 모델 분리로 변경 영향 최소화
- **Null 안전성**: DTO는 Nullable로 받고, Mapper에서 기본값/검증 적용
- **구조 평탄화**: 깊은 JSON(`sprites.other."official-artwork".front_default`)을 내부에선 `ImageUrl` 하나로 단순화

---

## 적용 흐름 (중요)

- **데이터 소스 계층**: `PokemonApiDataSource`가 PokeAPI로부터 JSON을 받아옴
- **DTO 변환**: 수신 JSON → `PokemonDto`로 역직렬화
- **저장소 계층**: `PokemonRepository`가 `PokemonApiDataSource`로부터 `Response<PokemonDto>`를 받음
- **모델 변환**: `PokemonRepository`가 **Mapper**를 호출해 DTO → `Pokemon` 모델 변환
- **응답**: 최종적으로 `PokemonRepository`는 `Pokemon` 모델을 반환

---

## DTO (System.Text.Json)

```csharp
using System.Text.Json.Serialization;

namespace CsharpStudy.HttpPokeMon.DTO;

public class PokemonDTO
{
    [JsonPropertyName("name")] public string? Name { get; set; }
    [JsonPropertyName("sprites")] public Sprites? Sprites { get; set; }

    // 평탄화된 파생 속성: official-artwork 우선, 없으면 front_default
    [JsonIgnore]
    public string? OfficialArtworkUrl =>
        Sprites?.Other?.OfficialArtwork?.FrontDefault
        ?? Sprites?.FrontDefault;

    public class Sprites
    {
        [JsonPropertyName("front_default")] public string? FrontDefault { get; set; }
        [JsonPropertyName("other")] public OtherBlock? Other { get; set; }
    }

    public class OtherBlock
    {
        [JsonPropertyName("official-artwork")] public OfficialArtworkData? OfficialArtwork { get; set; }
    }

    public class OfficialArtworkData
    {
        [JsonPropertyName("front_default")] public string? FrontDefault { get; set; }
    }
}

```

> 경로 확인: sprites.other["official-artwork"].front_default
>

---

## 도메인 모델 & Mapper

```csharp
namespace CsharpStudy.HttpPokeMon.Models;

public class Pokemon
{
    public Pokemon(string name, string imageUrl)
    {
        Name = name;            // 내부는 가급적 NonNull
        ImageUrl = imageUrl;
    }
    public string Name { get; }
    public string ImageUrl { get; }
}

```

```csharp
namespace CsharpStudy.HttpPokeMon.Mapping;

using CsharpStudy.HttpPokeMon.DTO;
using CsharpStudy.HttpPokeMon.Models;

public static class PokemonMapper
{
    public static Pokemon ToModel(this PokemonDTO dto)
    {
        var name = string.IsNullOrWhiteSpace(dto.Name) ? "Unknown" : dto.Name;
        var url  = dto.OfficialArtworkUrl ?? string.Empty; // 필요 시 검증/치환 추가
        return new Pokemon(name, url);
    }
}

```

---

## Repository 예시

```csharp
using System.Text.Json;
using CsharpStudy.HttpPokeMon.DTO;
using CsharpStudy.HttpPokeMon.Mapping;
using CsharpStudy.HttpPokeMon.Models;

public class PokemonRepository
{
    private readonly IPokemonApiDataSource _api;
    public PokemonRepository(IPokemonApiDataSource api) => _api = api;

    public async Task<Pokemon?> GetByNameAsync(string name)
    {
        try
        {
            var json = await _api.GetPokemonJsonAsync(name);
            var dto = JsonSerializer.Deserialize<PokemonDTO>(json,
                new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

            return dto?.ToModel(); // 실패 시 null
        }
        catch
        {
            // TODO: 로깅
            return null;
        }
    }
}

```

---

## Tips

- **라이브러리 통일**: System.Text.Json ↔ Newtonsoft.Json 어노테이션/역직렬화 함수 섞지 않기
- **Null 폴백**: `official-artwork`가 `null`일 수 있어 `sprites.front_default`로 폴백 준비
- **모델 일관성**: 내부 모델은 NonNull 유지 + Mapper에서 기본값/정규화
- **변경 격리**: 외부 API 스키마 변경 시 DTO/Mapper만 수정, 도메인 모델은 유지
- **성능/안정**: 역직렬화 옵션 명시(`PropertyNameCaseInsensitive` 등), 예외 로깅 추가