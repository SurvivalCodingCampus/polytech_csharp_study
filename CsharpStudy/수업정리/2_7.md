# 🌟 C# 동기/비동기 & Task 개념 정리

## 1. 동기 프로그래밍

- 코드가 순서대로 실행됨.
- 작업이 끝날 때까지 **다른 작업 중단**.
- 모든 작업은 앞의 작업이 끝날 때까지 **기다림**.

---

## 2. 서버 & 클라이언트

- 서버: 데이터를 주는 쪽
- 클라이언트: 데이터를 요청/받는 쪽
- 서버 ↔ 서버 간에도 데이터 요청/응답 가능

---

## 3. 스레드 vs 비동기

- **스레드(Thread)**: CPU 실행 단위. 실행 흐름을 늘리려면 직접 스레드 생성 → 컨텍스트 스위칭 비용↑
- **비동기(Async I/O)**: OS에 “작업 끝나면 알려줘” 맡김. CPU는 다른 일 계속 → 스레드 추가 없이 효율적.
- 👉 요약: **스레드 = 실행 줄 추가 / 비동기 = OS 알림 기반, 스레드 직접 추가 X**

---

## 4. 비동기 프로그래밍

- **작업 완료 기다리지 않고** 다른 작업 시작 가능.
- 핵심: **메인 스레드 절대 블로킹하지 않음**.

---

## 5. 동시성 & 병렬성

- **동시성(Concurrency)**: 여러 작업을 **논리적으로 동시에** 실행 (시분할). → “선생님이 여러 일 번갈아 처리”
- **병렬성(Parallelism)**: 여러 작업을 **물리적으로 동시에** 실행 (멀티코어). → “선생님+조교가 동시에 처리”

---

## 6. 콜백 기반의 문제

- 예측 어려움: 메인 스레드보다 늦게 끝날 수 있음.
- 디버깅 힘듦, 예외 처리 어려움.
- 병렬 처리에 비효율.

---

## 7. `ContinueWith()` vs `async/await`

- **ContinueWith**: 콜백 기반, try/catch 어렵고 가독성 ↓
- **async/await**: 동기 코드처럼 작성 가능, 예외·취소·병렬 처리 모두 용이

---

## 8. `async Task` 메서드 예시

```csharp
static async Task MyTask2()
{
    await Task.Delay(3000); // 3초 비동기 대기 (스레드 점유 X)
    Console.WriteLine("MyTask End");
}

```

- 호출 즉시 Task 반환
- 3초 대기 후 `"MyTask End"` 출력

---

## 9. Task 반환 사용법

1. **await**: 결과값 꺼내기
2. **Task 객체 직접 다루기**: 상태 추적, `Result`
3. **ContinueWith**: 후속 콜백 실행
4. **Task.WhenAll()**: 여러 작업 동시에 실행
5. **try/catch**: 예외 전파 처리

---

## 10. 병렬 처리

- **Task.WhenAll()**
    - 여러 작업을 동시에 실행 후, 모두 끝날 때까지 대기
    - 순차 실행(합산 시간) 대신 병렬 실행(최대 시간)

```csharp
var t1 = GetDataAsync();
var t2 = GetDataAsync();
await Task.WhenAll(t1, t2); // 동시에 실행 → 더 빠름

```

---

👉 **정리 한 줄**

- 동기 = 순차
- 스레드 = 실행 줄 추가
- 비동기 = OS에 맡기고 알림 받음
- 동시성 = 논리적 동시, 병렬성 = 물리적 동시
- `async/await` = 가독성, 안정성, 확장성 모두 최고