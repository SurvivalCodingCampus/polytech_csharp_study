* String & String Builder 차이점
String과 StringBuilder는 문자열을 다루는 자료형
String은 변경 불가능한 자료형이고, StringBuilder는 변경 가능한 자료형이다.

** String:
 - 변경 불가능한 자료형이므로, 문자열 연산(예: 연결, 수정)이 발생할 때마다 새로운 문자열 객체 생성
 - 문자열 연산이 잦은 경우 성능 저하를 유발할 수 있음.
 - 간단한 문자열 조작에 유용함.

** StringBuilder:
 - 변경 가능한 자료형으로, 문자열을 추가, 삭제, 수정할 때 기존 객체를 변경
 - 문자열 연산이 잦은 경우, 메모리 할당 및 객체 생성을 반복하지 않아 성능향상을 기대할 수 있음.
 - StringBuilder는 동기화를 지원하지 않으므로 단일 스레드 환경에서 사용하기 적합.

*** 요약
 - 간단한 문자열 조작에는 string을 사용하며, 잦은 문자열 연산에는 StringBuilder를 사용하는 것이 좋음.
 - String은 변경 불가능, StringBuilder는 변경 가능
 - 단일 스레드 환경에선 StringBuilder가 성능상 유리


---------------
25/08/25

* 디버깅
 - 소프트웨어의 오류 식별->원인 파악->수정->확인하는 과정. 올바른 동작을 보장하려면 필수
 
 ** 기본 도구
 - 로깅: 실행 중 이벤트/값을 기록해서 흐름을 눈으로 확인
 - 브레이크포인트: 특정 줄에서 실행을 멈춰 현재 상태를 관찰
 - 디버거: 일시정지, 한 줄 실행, 변수/메모리 검사 등 종합 도구
 - 스택 추적(call stack): "어떤 경로로 여기까지 왔는가"를 단계별로 확인
 
 * 디버깅 팁
 
 - 문제를 최소 재현 케이스로 축소
 - 차분히 실패-수정-재실행 루프를 반복하며 인내심 기르기!
 
 
 ---------------
 25/08/29
 
 * 람다식과 함수
 - Where는 조건을 걸어 원하는 데이터만 골라내는 함수
 - Select는 원하는 속성이나 변환된 값을 뽑아내는 함수
 - OrderBy는 지정된 기준에 따라 데이터를 정렬하는 함수
 - ForEach는 컬렉션의 모든 요소를 순회하며 동작을 수행하는 함수
 - Aggregate는 컬렉션을 누적 처리하여 하나의 결과로 줄이는 함수
 - Any는 조건을 만족하는 요소가 하나라도 있는지 확인하는 함수
 
 
 ---------------
 25/09/01
 
 * 예외 (Exception)
 - 프로그램 실행 중 발생할 수 있는 오류 상황을 처리하는 방법
 - try { 실행 코드 } catch (Exception e) { 예외 처리 }
 - finally 블록은 무조건 실행되는 코드
 - throw 키워드로 임의로 예외 발생 가능
 - 사용자 정의 예외 클래스도 작성 가능 (Exception 상속)
 
 
 * 에러 종류
 - Syntax Error : 문법 오류 (컴파일 시 발견)
 - Runtime Error : 실행 중 발생 (예외 처리 대상)
 - Logic Error : 논리적 오류, 결과가 의도와 다름
 
 
 * 파일 조작 (System.IO)
 - File.WriteAllText(path, text) : 파일에 내용 쓰기 (덮어씀)
 - File.ReadAllText(path) : 파일 전체 읽기
 - File.Copy(src, dest, true) : 파일 복사
 - File.Delete(path) : 파일 삭제
 
 
 ----------------------
 25/09/02 _ 여러가지 데이터 형식
 
 * CSV(Comma Separated Values) : 데이터베이스나 스프레드시트 프로그램과 호환되며, 데이터의 각 항목을 콤마(,)로 구분
 
 String str = "홍길동,한석봉, 신사임당";
 
 ◯ 장점: 단순하고 가벼움 -> Excel,DB, 스페리드
 ⨉ 단점: 데이터 타입 구분 없음(숫자, 문자열, 날짜 다 문자열로만 저장)
 
 
 * XML(eXtensible Markup Language) : 태그(<tag>..<tsg>)로 데이터 구조를 표현하는 텍스트 포맷
 
 <Department>
   <Name>총무부</Name>
   <Leader>
     <Name>홍길동</Name>
     <Age>41</Age>
   </Leader>
 </Department>
 
 ◯ 장점: 계층 구조(트리 구조) 표현 가능, 오래된 시스템과 호환성 좋음
 ⨉ 단점: 태그 때문에 용량이 큼, 파싱이 JSON보다 무거움
 
 
 * JSON(JavaScript Object Notation) : 키-값 {"key": "value"}와 배열[...]로 표현하는 포맷, 네트워크 통신에서 가장 많이 사용되고 있음.
 
 {
   "deptName": "총무부",
   "leader": {
     "name": "홍길동",
     "age": 41
   }
 }
 
 ◯ 장점: 계층 구조 표현 가능, 가볍고 단순(XML보다 용량 작음), 거의 모든 언어에서 직렬화/역직렬화 지원, 사람이 읽기 쉬움
 ⨉ 단점: 스키마(계획, 도식)가 약함
 
 
 ** 직렬화 세계의 공용어
  
  CSV: 단순 데이터 교환 (엑셀, DB, 로그)
  XML: 구조화+검증이 필요한 시스템 (옛날 공공기관, 금융)
  JSON: 현대 대부분의 네트워크/앱 통신 표준
  
  
  ▶ 직렬화 & 역직렬화
  
  * 직렬화(Serialization): 데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 포맷(ex. JSON, XML)으로 변환하는 과정
  * 역직렬화(Deserialization): 직렬화된 데이터를 객체로 복원하는 과정. 역직렬화를 통해 저장소나 네트워크를 통해 받은 데이터를 응용 프로그램에서 다시 사용할 수 있는 실제 객체로 변환할 수 있음.
  
  
  ---------------
  25/09/08 _ 비동기 프로그래밍
  
  * 동기(Synchronous)
  - 코드가 순서대로 실행됨.
  - 앞의 작업이 끝날 때까지 뒤의 작업은 기다림.
  - 직관적이고 이해하기 쉬움.
  - 시간이 오래 걸리는 작업(I/O, 네트워크, 파일 등)에서 프로그램이 멈춘 것처럼 보임
  ex> 1차선 도로
  
  * 비동기(Asychronous)
  - 작업이 완료되길 기다리지 않고 다른 작업을 이어서 처리
  - 메인 스레드를 먹지 않고, 앱이 즉각 반응성을 유지됨.
  - 주로 I/O작업에서 활용(파일,DB,네트워크)
  - async/await 문법으로 가독성 좋게 작성 가능
  ex> 여러 차선 도로
  
  * 동시성과 병렬성
  - 동시성(Concurrency):  하나의 CPU가 여러 작업을 번갈아가며 처리하는 것(논리적 동시에 실행)
  - 병렬성(Parallelism): 멀티코어에서 여러 작업을 물리적으로 동시에 실행하는 것.
  
  * 콜백(Callback)
  - 다른 함수의 인자로 전달되는 함수
  - 특정 작업이 끝난 후 실행될 동작을 정의할 때 사용
  - 비동기 처리에서 자주 사용됨
  
  ** 콜백의 한계 -> 콜백 지옥
  - 비동기 작업이 여러 단계로 중첩될 때 발생
  - 코드가 피라미드 형태로 깊어져 가독성이 급격히 떨어짐.
  - 흐름 파악이 어렵고, 예외 처리도 까다로움.
  - 유지보수/디버깅이 힘들어짐.
  
  ** 콜백 지옥 대안
  - async / await 문법 -> 마치 동기 코드처럼 순차적으로 작성 가능
  - Task.WhenAll 등을 이용해 병렬 실행도 쉽게 처리
  
  * 클라이언트와 서버 그리고 스레드
  
  ** 클라이언트(Client): 요청을 보내는 쪽
  ** 서버(Server): 요청을 받고 응답을 반환하는 쪽
  ** 스레드(Thread)
  - 프로그램 실행의 가장 작은 단위.
  - 하나의 프로세스(Process)는 여러 개의 스레드를 가질 수 있음.
  - 멀티스레드: 여러 스레드가 동시에 실행되며 동시성/병렬성을 가능하게 됨.
  
  
  
  -----------
  25/09/09 _DataSource
  
  * Data Source
  - 데이터 접근 방식을 실행 로직과 분리하는 구조
  - IDataSource(인터페이스) → 규칙 정의, JsonFileDataSource(구현체) → JSON 파일 읽기/쓰기 담당
  - Program은 인터페이스만 보고 로직 실행 (유연성 ↑)
  
  * 구성 요소
  - Person: 데이터 모델(이름/나이)
  - IDataSource: 데이터 읽기/저장 메서드 약속
  - JsonFileDataSource: JSON 직렬화/역직렬화로 파일 관리
  - Program: 데이터 불러오기, 추가, 삭제 흐름 실행
  
  
  ** 직렬화 / 역직렬화 _25/09/02 cf>
  - 직렬화(Serialize): 객체 → JSON 문자열
  - 역직렬화(Deserialize): JSON 문자열 → 객체
  - JsonSerializer.Serialize(), JsonSerializer.Deserialize<T>() 활용
  
  ** async / await / Task _25/09/08 cf>
  - Task: 미래에 끝날 작업을 표현하는 타입 (Task, Task<T>)
  - await: Task가 끝날 때까지 논블로킹 대기 (스레드는 다른 일 처리 가능)
  - async: 메서드가 await를 포함하고 Task를 반환함을 명시
  - 주로 I/O(파일, 네트워크, DB)에 활용 → UI 멈춤 방지, 반응성 유지
  
  ** 동기 / 비동기 _25/09/08 cf>
  - 동기(Synchronous): 순차 실행, 앞이 끝날 때까지 뒤가 기다림 (ex. 1차선 도로)
  - 비동기(Asynchronous): 기다리지 않고 다음 작업 처리 (ex. 여러 차선 도로)