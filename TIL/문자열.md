## String과 StringBuillder
### 1. **`String` 클래스**

- **불변(Immutable)**: `String`은 불변 객체입니다. 즉, 한 번 생성된 `String` 객체는 변경할 수 없습니다. 문자열을 수정하려고 할 때마다 새로운 `String` 객체가 생성됩니다.
- **성능**: 문자열을 자주 변경하거나 연결하는 작업이 있을 때, `String`을 사용하는 것은 비효율적입니다. 왜냐하면 문자열을 변경할 때마다 새로운 객체가 생성되고, 기존 객체는 가비지 컬렉션의 대상이 되기 때문입니다.
- **예시**:

    ```csharp
    string str = "Hello";
    str += " World";  // 새로운 문자열이 생성됨
    ```

  이 경우, `"Hello"`와 `" World"`를 합치려면 새로운 문자열을 생성하고, 기존의 두 문자열은 메모리에서 제거되기 때문에 비효율적일 수 있습니다.


### 2. **`StringBuilder` 클래스**

- **가변(Mutable)**: `StringBuilder`는 가변 객체로, 문자열을 수정할 수 있는 버퍼를 제공합니다. 문자열을 변경할 때마다 새로운 객체를 만들지 않고, 내부 버퍼를 재사용합니다.
- **성능**: 문자열을 자주 변경해야 하는 경우(예: 루프 안에서 문자열 연결) `StringBuilder`를 사용하는 것이 성능상 훨씬 유리합니다. 내부 버퍼를 사용하여 문자열을 수정하므로, 불필요한 객체 생성을 줄일 수 있습니다.
- **예시**:

    ```csharp
    StringBuilder sb = new StringBuilder("Hello");
    sb.Append(" World");  // 기존 버퍼에 추가
    ```

  이 예시에서는 새로운 `StringBuilder` 객체가 생성되지 않고, 기존의 버퍼가 수정됩니다.


### **주요 차이점 요약**

| 특성 | `String` | `StringBuilder` |
| --- | --- | --- |
| **불변성** | 불변 (immutable) | 가변 (mutable) |
| **성능** | 문자열을 자주 변경하면 비효율적 | 문자열을 자주 변경하면 효율적 |
| **메모리 사용** | 매번 새로운 객체를 생성하여 메모리 사용 | 내부 버퍼를 재사용하여 메모리 절약 |
| **용도** | 간단한 문자열 처리 | 반복적인 문자열 수정, 연결 시 사용 |

---

## Accessor와 Mutator
### 1. **Accessor** (접근자)

Accessor는 객체의 필드 값(속성)을 읽어오는 메서드입니다. 필드 값을 수정하지 않고, 단지 반환만 합니다. **Getter**라고도 불립니다.

- **예시**:

```java
public class Person {
    private String name;

    // Accessor (Getter)
    public String getName() {
        return name;
    }
}
```

- 여기서 `getName()` 메서드는 `name` 필드를 외부에서 읽을 수 있게 해주는 접근자입니다.

### 2. **Mutator** (변경자)

Mutator는 객체의 필드 값을 수정하는 메서드입니다. **Setter**라고도 불리며, 특정 필드의 값을 외부에서 변경할 수 있게 합니다.

- **예시**:

```java
public class Person {
    private String name;

    // Mutator (Setter)
    public void setName(String name) {
        this.name = name;
    }
}
```

- `setName()` 메서드는 `name` 필드 값을 외부에서 변경할 수 있도록 해주는 변경자입니다.